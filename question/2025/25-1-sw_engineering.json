{
    "meta": {
        "exam": {
            "name": "정보처리기사",
            "year": 2025,
            "session": 1
        },
        "subject": {
            "name": "소프트웨어 개발",
            "code": "SW_ENGINEERING"
        },
        "type": "multiple_choice_single",
        "language": "ko-KR",
        "note": "복원 기반 + 누락/불완전 항목은 유사 난이도로 자동 생성"
    },
    "questions": [
        {
            "no": 1,
            "topic": "해싱(키-주소 변환)",
            "question": "해싱(Hashing)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "키를 정렬하여 이진 탐색이 가능하도록 만드는 기법이다."
                },
                {
                    "no": 2,
                    "text": "키를 주소로 변환하여 저장 위치(버킷)를 계산하는 기법이다."
                },
                {
                    "no": 3,
                    "text": "피벗을 이용해 분할 정복으로 정렬하는 기법이다."
                },
                {
                    "no": 4,
                    "text": "연속 저장 방식으로 레코드를 저장하는 파일 조직 기법이다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "해싱은 Key를 Hash Function으로 주소(인덱스)로 매핑한다."
        },
        {
            "no": 2,
            "topic": "Brooks의 법칙",
            "question": "Brooks의 법칙에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "늦은 프로젝트에 인력을 추가하면 커뮤니케이션 비용 증가로 더 늦어질 수 있다."
                },
                {
                    "no": 2,
                    "text": "결함의 80%는 80% 모듈에서 발견된다."
                },
                {
                    "no": 3,
                    "text": "테스트를 많이 하면 결함이 완전히 사라진다."
                },
                {
                    "no": 4,
                    "text": "리팩터링은 일정에 영향을 주지 않는다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "Brooks의 법칙: 늦은 프로젝트에 인력 투입은 오히려 지연을 악화시킬 수 있다."
        },
        {
            "no": 3,
            "topic": "형상관리 도구",
            "question": "다음 중 대표적인 형상관리(버전관리) 도구로 가장 적절한 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "Git"
                },
                {
                    "no": 2,
                    "text": "JMeter"
                },
                {
                    "no": 3,
                    "text": "Wireshark"
                },
                {
                    "no": 4,
                    "text": "Figma"
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "Git은 분산 버전관리(형상관리) 도구이다."
        },
        {
            "no": 4,
            "topic": "형상관리 의미",
            "question": "소프트웨어 형상 관리(SCM)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "소프트웨어 변경을 통제하고 산출물을 체계적으로 관리한다."
                },
                {
                    "no": 2,
                    "text": "테스트 자동화 도구를 통칭한다."
                },
                {
                    "no": 3,
                    "text": "오직 유지보수 단계에서만 수행한다."
                },
                {
                    "no": 4,
                    "text": "빌드 도구(Ant/Maven/Gradle)를 의미한다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "SCM은 변경 통제/버전/베이스라인/감사 등 산출물 전반을 관리한다."
        },
        {
            "no": 5,
            "topic": "JSON",
            "question": "JSON에 대한 설명으로 가장 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "HTML 문서를 전송하기 위한 마크업 언어이다."
                },
                {
                    "no": 2,
                    "text": "키-값과 배열 구조를 갖는 경량 데이터 교환 형식이다."
                },
                {
                    "no": 3,
                    "text": "컴파일이 필요한 바이너리 포맷이다."
                },
                {
                    "no": 4,
                    "text": "관계형 데이터베이스의 스키마 정의 언어이다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "JSON은 경량 데이터 교환 포맷으로 객체(키-값)와 배열을 사용한다."
        },
        {
            "no": 6,
            "topic": "AJAX",
            "question": "AJAX에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "서버 간 파일 동기화를 위한 프로토콜이다."
                },
                {
                    "no": 2,
                    "text": "페이지 전체를 새로고침하지 않고 비동기 통신으로 일부만 갱신하는 기법이다."
                },
                {
                    "no": 3,
                    "text": "데이터베이스 정규화 기법이다."
                },
                {
                    "no": 4,
                    "text": "자바의 예외 처리 구문이다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "AJAX는 비동기 요청으로 화면 일부를 갱신한다."
        },
        {
            "no": 7,
            "topic": "퀵정렬(피벗)",
            "question": "퀵 정렬(Quick Sort)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "피벗을 기준으로 분할 후 재귀적으로 정렬한다."
                },
                {
                    "no": 2,
                    "text": "인접한 두 원소를 교환하며 큰 값을 뒤로 보낸다."
                },
                {
                    "no": 3,
                    "text": "이미 정렬된 경우에도 항상 O(N^2)이다."
                },
                {
                    "no": 4,
                    "text": "항상 안정 정렬(Stable Sort)이다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "퀵정렬은 피벗 기반 분할정복 방식이다."
        },
        {
            "no": 8,
            "topic": "삽입정렬",
            "question": "삽입 정렬(Insertion Sort)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "최솟값을 선택해 맨 앞으로 보내는 정렬이다."
                },
                {
                    "no": 2,
                    "text": "정렬된 부분에 원소를 적절한 위치로 삽입하며 진행한다."
                },
                {
                    "no": 3,
                    "text": "피벗을 선택하여 좌우로 분할한다."
                },
                {
                    "no": 4,
                    "text": "항상 O(NlogN)이다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "삽입 정렬은 앞쪽 정렬 구간에 하나씩 끼워 넣는다."
        },
        {
            "no": 9,
            "topic": "선형/비선형",
            "question": "다음 중 비선형(Non-linear) 자료구조에 해당하는 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "스택(Stack)"
                },
                {
                    "no": 2,
                    "text": "큐(Queue)"
                },
                {
                    "no": 3,
                    "text": "트리(Tree)"
                },
                {
                    "no": 4,
                    "text": "배열(Array)"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "트리는 계층 구조로 비선형 자료구조이다."
        },
        {
            "no": 10,
            "topic": "버전관리-공유 폴더 방식",
            "question": "버전관리 시스템의 방식 중 '공유 폴더 방식'에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "각 개발자가 로컬 저장소를 완전하게 복제하여 관리한다."
                },
                {
                    "no": 2,
                    "text": "중앙 서버의 저장소를 통해서만 변경 이력이 관리된다."
                },
                {
                    "no": 3,
                    "text": "공유 디렉터리에 파일을 복사/갱신하며 버전을 단순 관리하는 방식이다."
                },
                {
                    "no": 4,
                    "text": "블록체인 합의로 버전을 결정한다."
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "공유 폴더 방식은 단순 복사/백업 중심으로 충돌 관리가 약하다."
        },
        {
            "no": 11,
            "topic": "테스트 오라클",
            "question": "테스트 오라클(Test Oracle)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "테스트 자동 실행 도구의 한 종류이다."
                },
                {
                    "no": 2,
                    "text": "테스트 결과의 참/거짓을 판단하기 위한 기준(예상 결과/판정 근거)이다."
                },
                {
                    "no": 3,
                    "text": "테스트 환경을 격리하는 가상화 플랫폼이다."
                },
                {
                    "no": 4,
                    "text": "정적 분석을 수행하는 컴파일러 옵션이다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "오라클은 '정답(예상 결과) 여부'를 판정하는 근거이다."
        },
        {
            "no": 12,
            "topic": "단위 테스트(정의)",
            "question": "단위 테스트(Unit Test)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "전체 시스템을 실제 운영 환경에서 검증하는 테스트이다."
                },
                {
                    "no": 2,
                    "text": "모듈/함수 등 가장 작은 단위를 중심으로 명세대로 구현되었는지 검증한다."
                },
                {
                    "no": 3,
                    "text": "사용자 요구사항과 계약을 검증하는 인수 테스트이다."
                },
                {
                    "no": 4,
                    "text": "오직 블랙박스 기법만 사용한다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "단위 테스트는 개발자가 모듈 단위로 주로 화이트박스 관점에서 수행한다."
        },
        {
            "no": 13,
            "topic": "코드 인스펙션",
            "question": "코드 인스펙션(Code Inspection)에 대한 설명으로 가장 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "프로그램을 실행해 런타임 오류를 찾는 기법이다."
                },
                {
                    "no": 2,
                    "text": "정형화된 절차에 따라 소스코드를 리뷰하여 결함을 찾는 정적 검토 기법이다."
                },
                {
                    "no": 3,
                    "text": "네트워크 패킷을 캡처하여 보안 취약점을 분석한다."
                },
                {
                    "no": 4,
                    "text": "운영 중 사용자 피드백을 수집하여 기능을 개선한다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "인스펙션은 실행 없이 문서/코드 기반으로 결함을 발견한다."
        },
        {
            "no": 14,
            "topic": "상향식/하향식 설계",
            "question": "상향식(Bottom-up) 설계에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "상위 모듈부터 설계하고 점차 하위 모듈을 구체화한다."
                },
                {
                    "no": 2,
                    "text": "최하위 모듈을 먼저 설계/구현하고 점차 결합하여 상위 기능을 완성한다."
                },
                {
                    "no": 3,
                    "text": "인터페이스 정의 없이도 통합이 쉬운 방식이다."
                },
                {
                    "no": 4,
                    "text": "반드시 스텁(Stub)만 사용한다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "상향식은 하위 모듈부터 조립하듯 결합한다(드라이버를 자주 사용)."
        },
        {
            "no": 15,
            "topic": "통합 테스트",
            "question": "통합 테스트(Integration Test)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "개별 모듈 내부 로직을 상세히 검증한다."
                },
                {
                    "no": 2,
                    "text": "모듈 간 인터페이스/연동을 중심으로 결함을 검증한다."
                },
                {
                    "no": 3,
                    "text": "사용자가 실제 업무 시나리오로 최종 승인한다."
                },
                {
                    "no": 4,
                    "text": "테스트 케이스 없이 수행한다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "통합 테스트는 모듈 간 연결/데이터 교환/호출 관계를 검증한다."
        },
        {
            "no": 16,
            "topic": "정적/동적 분석(품질 분석 도구)",
            "question": "소스코드 품질 분석 도구의 정적 분석(Static Analysis)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "프로그램을 실행하면서 메모리/성능을 측정한다."
                },
                {
                    "no": 2,
                    "text": "실행 없이 코드 규칙/결함 패턴을 분석한다."
                },
                {
                    "no": 3,
                    "text": "실사용자 환경에서만 수행 가능하다."
                },
                {
                    "no": 4,
                    "text": "반드시 테스트 데이터가 필요하다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "정적 분석은 실행 없이 코드 기반으로 결함/규칙 위반을 찾는다."
        },
        {
            "no": 17,
            "topic": "정적/동적 분석(특징 아닌 것)",
            "question": "정적 분석 도구와 동적 분석 도구의 특징에 대한 설명으로 옳지 않은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "정적 분석은 실행 없이 결함을 탐지할 수 있다."
                },
                {
                    "no": 2,
                    "text": "동적 분석은 실행 중 행위(성능/메모리/런타임 오류)를 관찰한다."
                },
                {
                    "no": 3,
                    "text": "정적 분석은 테스트 케이스가 반드시 있어야만 수행할 수 있다."
                },
                {
                    "no": 4,
                    "text": "동적 분석은 특정 입력/실행 경로에 의존할 수 있다."
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "정적 분석은 테스트 케이스 없이도 수행 가능하다."
        },
        {
            "no": 18,
            "topic": "CMMI 성숙도 단계(복원)",
            "question": "CMMI(Capability Maturity Model Integration)의 성숙도 모델 단계가 아닌 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "설정(setting) 단계"
                },
                {
                    "no": 2,
                    "text": "정의(defined) 단계"
                },
                {
                    "no": 3,
                    "text": "초기(initial) 단계"
                },
                {
                    "no": 4,
                    "text": "최적화(optimizing) 단계"
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "CMMI 성숙도는 Initial/Managed/Defined/Quantitatively Managed/Optimizing로 구성된다."
        },
        {
            "no": 19,
            "topic": "ISO/IEC 25000(SQuaRE) (복원)",
            "question": "소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "소프트웨어 품질평가를 위한 통합모델 표준이다."
                },
                {
                    "no": 2,
                    "text": "System and Software Quality Requirements and Evaluation로 SQuaRE라고도 한다."
                },
                {
                    "no": 3,
                    "text": "ISO/IEC 2501n에서는 내부/외부/사용품질 측정과 품질측정요소 등을 다룬다."
                },
                {
                    "no": 4,
                    "text": "ISO/IEC 9126과 ISO/IEC 14598을 통합하였다."
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "내부/외부/사용품질 측정 등은 ISO/IEC 2502n 쪽 설명으로 보는 경우가 많다."
        },
        {
            "no": 20,
            "topic": "DRM 기술 요소(복원)",
            "question": "디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "크랙 방지 기술"
                },
                {
                    "no": 2,
                    "text": "정책 관리 기술"
                },
                {
                    "no": 3,
                    "text": "암호화 기술"
                },
                {
                    "no": 4,
                    "text": "방화벽 기술"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "방화벽은 네트워크 보안 요소로 DRM 핵심 기술 요소로 분류되지 않는다."
        },
        {
            "no": 21,
            "topic": "순차 파일(복원)",
            "question": "순차 파일(Sequential File)에 대한 설명으로 옳지 않은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "DASD의 물리적 주소로 각 레코드에 직접 접근한다."
                },
                {
                    "no": 2,
                    "text": "레코드를 순차 처리하므로 대화식 처리보다 일괄 처리에 적합하다."
                },
                {
                    "no": 3,
                    "text": "연속 저장으로 레코드 사이 빈 공간이 없어 저장 효율이 좋을 수 있다."
                },
                {
                    "no": 4,
                    "text": "매체 변환이 비교적 쉬워 다양한 매체에 적용 가능하다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "물리적 주소로 직접 접근은 직접(랜덤) 접근 파일 성격에 가깝다."
        },
        {
            "no": 22,
            "topic": "소프트웨어 패키징(복원)",
            "question": "소프트웨어 패키징에 대한 설명으로 틀린 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "패키징은 개발자 중심으로 진행한다."
                },
                {
                    "no": 2,
                    "text": "신규/변경 소스를 식별하고 모듈화하여 배포 가능한 형태로 만든다."
                },
                {
                    "no": 3,
                    "text": "고객 편의성을 위해 매뉴얼 및 버전관리를 지속한다."
                },
                {
                    "no": 4,
                    "text": "범용 환경에서 사용 가능하도록 일반 배포 형태로 진행한다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "패키징은 고객/운영 관점(배포/설치/사용성)을 강하게 고려한다."
        },
        {
            "no": 23,
            "topic": "블랙박스 테스트 유형(복원)",
            "question": "블랙박스 테스트(Black-box Test)의 유형으로 틀린 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "경계값 분석"
                },
                {
                    "no": 2,
                    "text": "오류 예측"
                },
                {
                    "no": 3,
                    "text": "동등 분할"
                },
                {
                    "no": 4,
                    "text": "조건, 루프 검사"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "조건/루프 검사는 화이트박스(구조 기반) 테스트 기법에 가깝다."
        },
        {
            "no": 24,
            "topic": "블랙박스 테스트로 찾기 어려운 오류(복원)",
            "question": "블랙박스 테스트를 이용하여 발견할 수 있는 오류가 아닌 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "비정상 입력에도 오류 처리가 수행되지 않는 경우"
                },
                {
                    "no": 2,
                    "text": "정상 입력에도 요구 기능이 제대로 수행되지 않는 경우"
                },
                {
                    "no": 3,
                    "text": "반복 조건을 만족하는데도 루프 내 문장이 수행되지 않는 경우"
                },
                {
                    "no": 4,
                    "text": "경계값 입력에서 요구된 출력이 나오지 않는 경우"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "루프 내부 실행 여부는 내부 구조를 보는 화이트박스 관점이 더 적합하다."
        },
        {
            "no": 25,
            "topic": "테스트 기본 원칙(결함 집중)",
            "question": "다음 설명의 소프트웨어 테스트 기본 원칙은?\n- 결함은 소수의 특정 모듈에 집중되어 존재하는 경향이 있다.",
            "choices": [
                {
                    "no": 1,
                    "text": "살충제 패러독스"
                },
                {
                    "no": 2,
                    "text": "결함 집중"
                },
                {
                    "no": 3,
                    "text": "오류 부재의 궤변"
                },
                {
                    "no": 4,
                    "text": "완벽한 테스팅은 불가능"
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "Defect Clustering(결함 집중) 원칙이다."
        },
        {
            "no": 26,
            "topic": "테스트 드라이버(복원)",
            "question": "테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "시험대상 모듈을 호출하는 간이 소프트웨어이다."
                },
                {
                    "no": 2,
                    "text": "필요 시 매개변수를 전달하고 결과를 확인할 수 있다."
                },
                {
                    "no": 3,
                    "text": "상향식 통합 테스트에서 사용된다."
                },
                {
                    "no": 4,
                    "text": "테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다."
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "④는 스텁(Stub)에 대한 설명이다."
        },
        {
            "no": 27,
            "topic": "버블 정렬 PASS1(복원)",
            "question": "버블 정렬로 다음 자료를 오름차순 정렬할 때 PASS1 결과는?\n9, 6, 7, 3, 5",
            "choices": [
                {
                    "no": 1,
                    "text": "6, 9, 7, 3, 5"
                },
                {
                    "no": 2,
                    "text": "3, 9, 6, 7, 5"
                },
                {
                    "no": 3,
                    "text": "3, 6, 7, 9, 5"
                },
                {
                    "no": 4,
                    "text": "6, 7, 3, 5, 9"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "PASS1에서 최댓값 9가 맨 뒤로 이동한다."
        },
        {
            "no": 28,
            "topic": "정렬 알고리즘 시간복잡도(합병)",
            "question": "정렬된 N개의 데이터를 처리하는데 O(Nlog2 N)의 시간이 소요되는 정렬 알고리즘은?",
            "choices": [
                {
                    "no": 1,
                    "text": "선택 정렬"
                },
                {
                    "no": 2,
                    "text": "삽입 정렬"
                },
                {
                    "no": 3,
                    "text": "버블 정렬"
                },
                {
                    "no": 4,
                    "text": "합병(병합) 정렬"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "병합 정렬은 대표적인 O(NlogN) 정렬이다."
        },
        {
            "no": 29,
            "topic": "테스트 커버리지 도구(복원)",
            "question": "테스트 커버리지 분석 도구가 아닌 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "JaCoCo"
                },
                {
                    "no": 2,
                    "text": "Cobertura"
                },
                {
                    "no": 3,
                    "text": "Clover"
                },
                {
                    "no": 4,
                    "text": "CSS"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "CSS는 스타일시트로 커버리지 도구가 아니다."
        },
        {
            "no": 30,
            "topic": "Postfix 계산(복원)",
            "question": "다음 Postfix 연산식의 결과로 옳은 것은?\n3 4 * 5 6 * +",
            "choices": [
                {
                    "no": 1,
                    "text": "35"
                },
                {
                    "no": 2,
                    "text": "42"
                },
                {
                    "no": 3,
                    "text": "77"
                },
                {
                    "no": 4,
                    "text": "360"
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "(3×4)+(5×6)=12+30=42"
        },
        {
            "no": 31,
            "topic": "Infix→Postfix 변환(복원)",
            "question": "중위 표기법 (A+B)*C+(D+E)를 후위 표기법(Postfix)으로 옳게 표기한 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "AB+CDE*++"
                },
                {
                    "no": 2,
                    "text": "AB+C*DE++"
                },
                {
                    "no": 3,
                    "text": "+AB*C+DE+"
                },
                {
                    "no": 4,
                    "text": "+*+ABC+DE"
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "(A+B)C* + (D+E)+ → AB+ C* DE+ +"
        },
        {
            "no": 32,
            "topic": "자료구조(선형/비선형) (복원)",
            "question": "자료구조에 대한 설명으로 옳지 않은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "스택은 LIFO 처리를 수행한다."
                },
                {
                    "no": 2,
                    "text": "큐는 FIFO 처리를 수행한다."
                },
                {
                    "no": 3,
                    "text": "스택은 서브루틴 호출, 인터럽트 처리, 수식 계산 등에 응용된다."
                },
                {
                    "no": 4,
                    "text": "큐는 비선형 구조에 해당한다."
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "큐는 선형 자료구조이다."
        },
        {
            "no": 33,
            "topic": "전위 순회(복원-그림 생략)",
            "question": "다음 트리를 전위 순회(Preorder traversal)한 결과로 옳은 것은? (트리 그림 생략: 복원 기반)",
            "choices": [
                {
                    "no": 1,
                    "text": "+ * A B / * C D E"
                },
                {
                    "no": 2,
                    "text": "A B / C * D * E +"
                },
                {
                    "no": 3,
                    "text": "A / B * C * D + E"
                },
                {
                    "no": 4,
                    "text": "+ * * / A B C D E"
                }
            ],
            "answer": {
                "choiceNo": 4
            },
            "explanation": "그림이 누락된 복원 문항으로, 전위 순회(루트→좌→우) 결과를 기준으로 답을 구성했다."
        },
        {
            "no": 34,
            "topic": "테스트 vs 디버깅(복원)",
            "question": "테스트(Test)와 디버깅(Debug)의 목적에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다."
                },
                {
                    "no": 2,
                    "text": "테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다."
                },
                {
                    "no": 3,
                    "text": "둘 다 오류를 찾기만 하며 수정은 하지 않는다."
                },
                {
                    "no": 4,
                    "text": "둘 다 오류의 발견/수정과 무관하다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "테스트는 결함 발견, 디버깅은 원인 추적 및 수정 활동이다."
        },
        {
            "no": 35,
            "topic": "형상관리 설명(복원-도구 오답 포함)",
            "question": "소프트웨어 형상 관리에 대한 설명으로 거리가 먼 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "변경을 제어하고 관리한다."
                },
                {
                    "no": 2,
                    "text": "계획서/설계서/코드/테스트케이스 등도 관리 대상이 될 수 있다."
                },
                {
                    "no": 3,
                    "text": "대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다."
                },
                {
                    "no": 4,
                    "text": "개발 단계에도 적용할 수 있다."
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "Ant/Maven/Gradle은 빌드 도구로, 형상관리 도구 분류로는 부적절하다."
        },
        {
            "no": 36,
            "topic": "DRM과 거리가 먼 것(복원)",
            "question": "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "콘텐츠 암호화 및 키 관리"
                },
                {
                    "no": 2,
                    "text": "콘텐츠 식별체계 표현"
                },
                {
                    "no": 3,
                    "text": "콘텐츠 오류 감지 및 복구"
                },
                {
                    "no": 4,
                    "text": "라이선스 발급 및 관리"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "DRM은 암호화/식별/권한(라이선스) 관리가 핵심이다."
        },
        {
            "no": 37,
            "topic": "품질 목표(사용성) (복원)",
            "question": "소프트웨어 품질 목표 중 쉽게 배우고 사용할 수 있는 정도를 나타내는 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "Correctness"
                },
                {
                    "no": 2,
                    "text": "Reliability"
                },
                {
                    "no": 3,
                    "text": "Usability"
                },
                {
                    "no": 4,
                    "text": "Integrity"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "Usability는 학습/사용 용이성을 포함한다."
        },
        {
            "no": 38,
            "topic": "파레토 법칙(테스트) (복원)",
            "question": "소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?",
            "choices": [
                {
                    "no": 1,
                    "text": "Brooks의 법칙"
                },
                {
                    "no": 2,
                    "text": "Boehm의 법칙"
                },
                {
                    "no": 3,
                    "text": "Pareto의 법칙"
                },
                {
                    "no": 4,
                    "text": "Jackson의 법칙"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "테스트 원칙의 근거로 자주 언급되는 파레토 법칙이다."
        },
        {
            "no": 39,
            "topic": "경계값 분석(복원-표 오류 포함)",
            "question": "경계값 분석 기법으로 성적부여 로직을 테스트할 때 입력값으로 옳지 않은 것은? (표는 복원 기반)\n- 80~100: A\n- 60~79: B\n- 60~79: C",
            "choices": [
                {
                    "no": 1,
                    "text": "59"
                },
                {
                    "no": 2,
                    "text": "80"
                },
                {
                    "no": 3,
                    "text": "90"
                },
                {
                    "no": 4,
                    "text": "101"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "복원 문제의 정답 표기를 따라 구성했다(원문 표가 불완전할 수 있음)."
        },
        {
            "no": 40,
            "topic": "테스트 케이스(복원)",
            "question": "테스트 케이스(Test Case)와 관련한 설명으로 틀린 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "테스트 목표/방법을 결정하기 전에 테스트 케이스를 작성해야 한다."
                },
                {
                    "no": 2,
                    "text": "결함이 있어도 정상 결과가 나올 수 있어, 결함을 드러내는 케이스 설계가 중요하다."
                },
                {
                    "no": 3,
                    "text": "입력값, 실행 조건, 예상 결과의 집합으로 볼 수 있다."
                },
                {
                    "no": 4,
                    "text": "통과/실패 판단 기준을 테스트 오라클이라고 한다."
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "일반적으로 목표/범위/전략 수립 후 케이스를 설계한다."
        },
        {
            "no": 41,
            "topic": "통합 테스트 유형(하향식) (복원)",
            "question": "다음이 설명하는 애플리케이션 통합 테스트 유형은?\n- 깊이 우선/너비 우선 방식\n- 상위 컴포넌트부터 점증적으로 하위 컴포넌트를 테스트\n- 하위 컴포넌트 미완성 시 스텁 사용",
            "choices": [
                {
                    "no": 1,
                    "text": "하향식 통합 테스트"
                },
                {
                    "no": 2,
                    "text": "상향식 통합 테스트"
                },
                {
                    "no": 3,
                    "text": "회귀 테스트"
                },
                {
                    "no": 4,
                    "text": "빅뱅 테스트"
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "상위부터 내려가며 스텁으로 하위를 대체하는 하향식 방식이다."
        },
        {
            "no": 42,
            "topic": "Alien Code(복원)",
            "question": "외계인 코드(Alien Code)에 대한 설명으로 옳은 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "로직이 복잡해 이해하기 어려운 코드를 의미한다."
                },
                {
                    "no": 2,
                    "text": "오래되었거나 문서/개발자 부재로 유지보수가 어려운 코드를 의미한다."
                },
                {
                    "no": 3,
                    "text": "오류가 없어 디버깅이 필요 없는 코드를 의미한다."
                },
                {
                    "no": 4,
                    "text": "사용자가 직접 작성한 코드를 의미한다."
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "레거시 + 맥락 부재로 '누가/왜'를 알기 어려운 코드라는 의미로 사용된다."
        },
        {
            "no": 43,
            "topic": "테스트 오라클(용어) (복원)",
            "question": "다음이 설명하는 테스트 용어는?\n- 결과가 참/거짓인지 판단하기 위해 사전에 정의된 참값(정답)을 기준으로 비교\n- 참/샘플링/휴리스틱/일관성 검사 등이 존재",
            "choices": [
                {
                    "no": 1,
                    "text": "테스트 케이스"
                },
                {
                    "no": 2,
                    "text": "테스트 시나리오"
                },
                {
                    "no": 3,
                    "text": "테스트 오라클"
                },
                {
                    "no": 4,
                    "text": "테스트 데이터"
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "오라클은 '판정 기준' 자체를 의미한다."
        },
        {
            "no": 44,
            "topic": "Deque(복원)",
            "question": "양 방향에서 입·출력이 가능한 선형 자료구조로, 양쪽 끝에서 삽입·삭제가 가능한 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "데크(Deque)"
                },
                {
                    "no": 2,
                    "text": "스택(Stack)"
                },
                {
                    "no": 3,
                    "text": "큐(Queue)"
                },
                {
                    "no": 4,
                    "text": "트리(Tree)"
                }
            ],
            "answer": {
                "choiceNo": 1
            },
            "explanation": "Deque는 Double Ended Queue이다."
        },
        {
            "no": 45,
            "topic": "단위 테스트(스텁/드라이버) (복원)",
            "question": "단위 테스트(Unit Test)와 관련한 설명으로 틀린 것은?",
            "choices": [
                {
                    "no": 1,
                    "text": "모듈 개발 완료 후 명세대로 구현되었는지 검증한다."
                },
                {
                    "no": 2,
                    "text": "모듈 내부 구조를 볼 수 있는 구조적 테스트를 주로 시행한다."
                },
                {
                    "no": 3,
                    "text": "테스트 인자를 넘겨주고 결과를 받는 가상 모듈을 스텁(Stub)이라 한다."
                },
                {
                    "no": 4,
                    "text": "테스트할 모듈을 호출하는 모듈(드라이버)도 있고, 호출되는 모듈(스텁)도 있다."
                }
            ],
            "answer": {
                "choiceNo": 3
            },
            "explanation": "인자를 넘겨주고 결과를 받는 호출자 역할은 드라이버(Driver) 설명에 가깝다."
        },
        {
            "no": 46,
            "topic": "알파/베타 테스트 단계(복원)",
            "question": "알파(Alpha), 베타(Beta) 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",
            "choices": [
                {
                    "no": 1,
                    "text": "단위 테스트"
                },
                {
                    "no": 2,
                    "text": "인수 테스트"
                },
                {
                    "no": 3,
                    "text": "통합 테스트"
                },
                {
                    "no": 4,
                    "text": "시스템 테스트"
                }
            ],
            "answer": {
                "choiceNo": 2
            },
            "explanation": "알파/베타는 사용자 관점 검증(인수 테스트) 범주로 다루는 경우가 많다."
        }
    ]
}
